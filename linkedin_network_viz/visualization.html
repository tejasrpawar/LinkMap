<!DOCTYPE html>
<meta charset="utf-8">
<style>
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
        color: #333;
    }

    .back-button {
        position: fixed;
        top: 20px;
        left: 20px;
        padding: 10px 20px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s ease;
        z-index: 1000;
    }

    .back-button:hover {
        background-color: #2980b9;
    }

    /* D3 Visualization Styles */
    .links line {
        stroke: #999;
        stroke-opacity: 0.4;
        stroke-width: 1px;
        transition: stroke-opacity 0.3s ease;
    }

    .links line:hover {
        stroke-opacity: 0.8;
    }

    .nodes circle {
        stroke: #fff;
        stroke-width: 2px;
        transition: all 0.3s ease;
    }

    .nodes circle:hover {
        stroke-width: 3px;
        cursor: pointer;
    }

    text {
        font-family: 'Segoe UI', sans-serif;
        font-size: 11px;
        fill: #333;
        pointer-events: none;
    }

    svg {
        background-color: white;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
</style>

<button class="back-button" onclick="window.location.href='index.html'">‚Üê Back</button>
<svg height="0"></svg>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/1.0.11/jquery.csv.min.js"></script>
<script>
    // Get data from localStorage
    const csvData = localStorage.getItem('linkedinData');
    if (!csvData) {
        window.location.href = 'index.html';
    }

    // Parse CSV data
    function parseCSV(csvData) {
        try {
            // Split the CSV into lines
            const lines = csvData.split('\n');
            
            // Find the start of the actual data (skip LinkedIn's header notes)
            let startIndex = 0;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes('First Name,Last Name,')) {
                    startIndex = i;
                    break;
                }
            }

            // Get the actual data rows
            const dataLines = lines.slice(startIndex);
            const cleanCSV = dataLines.join('\n');
            
            return $.csv.toObjects(cleanCSV);
        } catch (error) {
            console.error('Error parsing CSV:', error);
            return [];
        }
    }

    // Process the connections
    const connections = parseCSV(csvData);
    console.log('Parsed connections:', connections); // Debug log

    // Clear localStorage after getting the data
    localStorage.removeItem('linkedinData');

    // Initialize arrays
    const nodes = [];
    const links = [];

    // Process connections into nodes and links
    const companies = {};
    
    connections.forEach(connection => {
        // Skip empty rows
        if (!connection['First Name'] && !connection['Last Name']) return;

        const name = `${connection['First Name']} ${connection['Last Name']}`.trim();
        const company = (connection['Company'] || 'Unknown').trim();
        
        // Skip if no name
        if (!name) return;

        if (!companies[company]) {
            companies[company] = [];
        }
        companies[company].push(name);
        
        nodes.push({
            name: name,
            company: company
        });
    });

    console.log('Processed nodes:', nodes); // Debug log
    console.log('Companies:', companies); // Debug log

    // Create links between people in the same company
    Object.keys(companies).forEach(company => {
        const companyPeople = companies[company];
        if (companyPeople.length >= 2) { // Changed minimum company size to 2
            for (let i = 0; i < companyPeople.length; i++) {
                for (let j = i + 1; j < companyPeople.length; j++) {
                    links.push({
                        source: companyPeople[i],
                        target: companyPeople[j],
                        company: company
                    });
                }
            }
        }
    });

    console.log('Generated links:', links); // Debug log

    // Create the visualization
    let simulation;

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    function render(graph) {
        const width = window.innerWidth - 40;
        const height = window.innerHeight - 40;

        // Clear any existing SVG content
        d3.select("svg").selectAll("*").remove();

        const svg = d3.select("svg")
            .attr("width", width)
            .attr("height", height);

        // Add zoom behavior
        const g = svg.append("g");
        const zoom = d3.zoom()
            .scaleExtent([1, 8])
            .on("zoom", zoomed);
        
        svg.call(zoom);

        function zoomed() {
            g.attr("transform", d3.event.transform);
        }

        const color = d3.scaleOrdinal(d3.schemeCategory20);

        simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.name))
            .force("charge", d3.forceManyBody().strength(-100))
            .force("center", d3.forceCenter(width / 2, height / 2));

        const link = g.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graph.links)
            .enter().append("line");

        const node = g.append("g")
            .attr("class", "nodes")
            .selectAll("g")
            .data(graph.nodes)
            .enter().append("g");

        const circles = node.append("circle")
            .attr("r", 5)
            .attr("fill", d => color(d.company))
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended))
            .on("click", clicked);

        const labels = node.append("text")
            .text(d => d.name)
            .attr('x', 6)
            .attr('y', 3);

        node.append("title")
            .text(d => `${d.name} (${d.company})`);

        simulation
            .nodes(graph.nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(graph.links);

        function ticked() {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("transform", d => `translate(${d.x},${d.y})`);
        }

        function clicked(d) {
            const transition = svg.transition().duration(750);
            
            // Find all nodes in the same company
            const companyNodes = graph.nodes.filter(n => n.company === d.company);
            
            if (companyNodes.length > 1) {
                // Get current transform
                const currentTransform = d3.zoomTransform(svg.node());
                
                // If we're already zoomed in (scale > 1), reset to default view
                if (currentTransform.k > 1) {
                    svg.transition(transition)
                        .call(zoom.transform, d3.zoomIdentity);
                    return;
                }
                
                // Calculate the bounding box of the company cluster
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                companyNodes.forEach(node => {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x);
                    maxY = Math.max(maxY, node.y);
                });

                // Add padding
                const padding = 50;
                const dx = maxX - minX + padding;
                const dy = maxY - minY + padding;
                const x = (minX + maxX) / 2;
                const y = (minY + maxY) / 2;
                const scale = Math.min(4, 0.9 / Math.max(dx / width, dy / height));
                
                svg.transition(transition)
                    .call(zoom.transform, d3.zoomIdentity
                        .translate(width / 2, height / 2)
                        .scale(scale)
                        .translate(-x, -y));
            }
        }
    }

    // Render the visualization
    render({ nodes: nodes, links: links });

    // Handle window resize
    window.addEventListener('resize', function() {
        render({ nodes: nodes, links: links });
    });
</script> 